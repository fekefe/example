/**
 * 设计模式
 * Created by gaoquan on 2017/3/24.
 * <p>
 * {@link com.gof.adapter } 适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
 * {@link com.gof.command } 命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以支持可撤销的操作。
 * {@link com.gof.compositor } 组合模式：将对象组合成树形结构以表示“整体－部分”的层次结构。Compositor使得用户对单个对象和组合对象的使用具有一致性。
 * {@link com.gof.decorator } 装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
 * {@link com.gof.facade } 外观模式：隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。
 * {@link com.gof.factory } 工厂模式：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
 * {@link com.gof.Iterator } 迭代器模式：用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
 * {@link com.gof.mediator } 中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
 * {@link com.gof.memento } 备忘录模式：保存一个对象的某个状态，以便在适当的时候恢复对象。
 * {@link com.gof.observer } 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
 * {@link com.gof.proxy } 动态代理：CGLIB，JDK
 * {@link com.gof.singleton } 单例模式：
 * {@link com.gof.state } 状态模式：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
 * {@link com.gof.strategy } 策略模式：定义一系列的算法，把它们一个个封装起来, 并且使它们可相互替换。
 * {@link com.gof.template } 模板模式：一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于对象行为型模式。
 * {@link com.gof.visitor } 访问者模式：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
 * {@link com.gof.prototype } 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
 */
package com.gof;